<!DOCTYPE html>
<head>
    <meta charset="utf-8">
    <script src="https://d3js.org/d3.v4.min.js"></script>


    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.2.0/dist/leaflet.css"
          integrity="sha512-M2wvCLH6DSRazYeZRIm1JnYyh22purTM+FDB5CsyxtQJYeKq83arPe5wgbNmcFXGqiSH2XR8dT/fJISVA1r/zQ=="
          crossorigin=""/>

    <script src="heatmap_data.js"></script>
    <script src="./heatmap.min.js"></script>

    <script src="https://unpkg.com/leaflet@1.2.0/dist/leaflet.js"
            integrity="sha512-lInM/apFSqyy1o6s89K4iQUKg6ppXEgsVxT35HbzUupEVRh2Eu9Wdl4tHj7dZO0s1uvplcYGmt3498TtHq+log=="
            crossorigin=""></script>
            
    <script src="./heatmap_overlay.js"></script>
    <script src="./code2genre.js"></script>
    <script src="./genre2code.js"></script>

    <script src='http://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js'></script>
    <script src='https://rawgit.com/zeusdeux/fuzzy-dropdown/master/dist/fuzzy-dropdown.min.js'></script>

    <link href="https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.6-rc.0/css/select2.min.css" rel="stylesheet"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.6-rc.0/js/select2.min.js"></script>


</head>

<body>
<div id="control-pane">
    <h2> Genres </h2>
    <select id="genresList" title="genres" multiple="multiple">
    </select>
    <!--<div id="fuzzSearch">-->
        <!--<div id="fuzzNameContainer">-->
            <!--<span class="fuzzName"></span>-->
            <!--<span class="fuzzArrow"></span>-->
        <!--</div>-->
        <!--<div id="fuzzDropdownContainer">-->
            <!--<input type="text" value="" class="fuzzMagicBox" placeholder="search.."/>-->
            <!--<span class="fuzzSearchIcon"></span>-->
            <!--<ul id="fuzzResults">-->
            <!--</ul>-->
        <!--</div>-->
    <!--</div>-->
    <!--<script>-->
    <!--$('#fuzzOptionsList').fuzzyDropdown({-->
    <!--mainContainer: '#fuzzSearch',-->
    <!--arrowUpClass: 'fuzzArrowUp',-->
    <!--selectedClass: 'selected',-->
    <!--enableBrowserDefaultScroll: true-->
    <!--});-->
    <!--</script>-->

</div>

<div id="map-container"></div>

<div id="vis">
    <button id="play-button">Play</button>
</div>


<script>

    var formatDateIntoYear = d3.timeFormat("%b %Y");
    var formatDate = d3.timeFormat("%b %Y");
    //    var parseDate = d3.timeParse("%m/%d/%y");
    var parseDate = d3.timeParse("%d/%m/%Y");

    var startDate = new Date("1930-01-01"),
        endDate = new Date("2017-12-01");


    var margin = {top: 50, right: 50, bottom: 0, left: 50},
        width = 960 - margin.left - margin.right,
        height = 500 - margin.top - margin.bottom;

    var svg = d3.select("#vis")
        .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom);

    ////////// map ////////////

    var radius = 0.5,
        minOpacity = 0,
        maxOpacity = 0.5,
        scaleRadius = true,
        useLocalExtrema = true,
        lat = 46.79,
        lng = 8.20,
        zoom = 8;
    //            data = {
    //                max: 8,
    //                data: [{x: 24.6408, y: 46.7728, value: 3}, {x: 50.75, y: -1.55, data: 1}]
    //            };


    var cfg = {
        // radius should be small ONLY if scaleRadius is true (or small radius is intended)
        // if scaleRadius is false it will be the constant radius used in pixels
        "radius": radius,
        // "maxOpacity": .5,
        "minOpacity": minOpacity,
        "maxOpacity": maxOpacity,
        // scales the radius based on map zoom
        "scaleRadius": scaleRadius,
        // if set to false the heatmap uses the global maximum for colorization
        // if activated: uses the data maximum within the current map boundaries
        //   (there will always be a red spot with useLocalExtremas true)
        "useLocalExtrema": useLocalExtrema,
        // which field name in your data represents the latitude - default "lat"
        latField: 'x',
        // which field name in your data represents the longitude - default "lng"
        lngField: 'y',
        // which field name in your data represents the data value - default "value"
        valueField: 'valueField'
    };

    var heatmapLayer = new HeatmapOverlay(cfg);

    var tonerUrl = "http://{S}tile.stamen.com/toner/{Z}/{X}/{Y}.png";
    var url = tonerUrl.replace(/({[A-Z]})/g, function (s) {
        return s.toLowerCase();
    });

    var baseLayer = L.tileLayer(
        url, {
            subdomains: ['', 'a.', 'b.', 'c.', 'd.'],
            minZoom: 0,
            maxZoom: 20,
            type: 'png',
            attribution: 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, ' +
            'under <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a>. ' +
            'Data by <a href="http://openstreetmap.org">OpenStreetMap</a>, under ' +
            '<a href="http://creativecommons.org/licenses/by-sa/3.0">CC BY SA</a>'
        }
    );

    var map = new L.Map("map-container", {
        center: new L.LatLng(lat, lng),
        zoom: zoom,
        layers: [baseLayer, heatmapLayer]
    });

    function leafletMap() {

        function my(selection) {
            // generate chart here, using `width` and `height`
            console.log("my called!")

            selection.each(function (d, i) {
                // generate chart here; `d` is the data and `this` is the element
                heatmapLayer.setData(d)
                console.log("set data:" + d) // TODO inja aslan nemire dadach!
            });


        }

        // Getter-Setter Methods for eanbaling syntax chaining

        my.width = function (value) {
            if (!arguments.length) return width;
            width = value;
            return my;
        };

        my.height = function (value) {
            if (!arguments.length) return height;
            height = value;
            return my;
        };

        my.radius = function (value) {
            if (!arguments.length) return radius;
            radius = value;
            return my;
        };

        my.minOpacity = function (value) {
            if (!arguments.length) return minOpacity;
            minOpacity = value;
            return my;
        };

        my.maxOpacity = function (value) {
            if (!arguments.length) return maxOpacity;
            maxOpacity = value;
            return my;
        };

        my.scaleRadius = function (value) {
            if (!arguments.length) return scaleRadius;
            scaleRadius = value;
            return my;
        };

        my.useLocalExtrema = function (value) {
            if (!arguments.length) return useLocalExtrema;
            useLocalExtrema = value;
            return my;
        };

        my.lat = function (value) {
            if (!arguments.length) return lat;
            lat = value;
            return my;
        };

        my.lng = function (value) {
            if (!arguments.length) return lng;
            lng = value;
            return my;
        };

        my.zoom = function (value) {
            if (!arguments.length) return zoom;
            zoom = value;
            return my;
        };

//        my.data = function (value) {
//            if (!arguments.length) return data;
//            data = value;
//            return my;
//        };

        return my;
    }

    ////////// slider //////////

    var moving = false;
    var currentValue = 0;
    var targetValue = width;

    var playButton = d3.select("#play-button");

    var x = d3.scaleTime()
        .domain([startDate, endDate])
        .range([0, targetValue])
        .clamp(true);

    var slider = svg.append("g")
        .attr("class", "slider")
        .attr("transform", "translate(" + margin.left + "," + height / 5 + ")");

    slider.append("line")
        .attr("class", "track")
        .attr("x1", x.range()[0])
        .attr("x2", x.range()[1])
        .select(function () {
            return this.parentNode.appendChild(this.cloneNode(true));
        })
        .attr("class", "track-inset")
        .select(function () {
            return this.parentNode.appendChild(this.cloneNode(true));
        })
        .attr("class", "track-overlay")
        .call(d3.drag()
            .on("start.interrupt", function () {
                slider.interrupt();
            })
            .on("start drag", function () {
                currentValue = d3.event.x;
                update(x.invert(currentValue));
            })
        );

    slider.insert("g", ".track-overlay")
        .attr("class", "ticks")
        .attr("transform", "translate(0," + 18 + ")")
        .selectAll("text")
        .data(x.ticks(10))
        .enter()
        .append("text")
        .attr("x", x)
        .attr("y", 10)
        .attr("text-anchor", "middle")
        .text(function (d) {
            return formatDateIntoYear(d);
        });

    var handle = slider.insert("circle", ".track-overlay")
        .attr("class", "handle")
        .attr("r", 9);

    var label = slider.append("text")
        .attr("class", "label")
        .attr("text-anchor", "middle")
        .text(formatDate(startDate))
        .attr("transform", "translate(0," + (-25) + ")")


    ////////// plot //////////

    var dataset;
    var filtered_data;

    var plot = svg.append("g")
        .attr("class", "plot")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    //    function loadData(start, len) {
    //        var points = heatmap_data.slice(start, start + len);
    function loadData(points) {
        var len = points.length;
        var newpoints = [];
        var max = 0;
        // var width = 840;
        // var height = 400;
        while (len--) {
            var val = points[len];
            max = Math.max(max, val);
            var point = {x: val.x, y: val.y, value: val.value};
            newpoints.push(point);
        }
        var data = {max: max, data: newpoints};
        myloadedData = data;
        return data;
    }


    function selectedOption() {
        log.console("Selected Option!")
    }

    function setOptions() {


    }

    var available_genres;

    function calcAvailableOptions() {
        let all_genres_options = [];
        for (r = 0; r < filtered_data.length; r++) {
            for (i = 0; i < filtered_data[r].genre.length; i++) {
                all_genres_options.push(filtered_data[r].genre[i]);
            }
        }
        available_genres = Array.from(new Set(all_genres_options))
    }


    d3.csv("heatmap_date_freq_coord_genre.csv", prepare, function (data) {
        dataset = data;
        filtered_data = data;
        calcAvailableOptions();

        // Adding (Filtering) Options

        d3.select('body')
        //            .select('#control-pane')
            .select('#genresList')
            //            .append('div')
            //            .append('select')
            //              .on('change',change)
            //              .on('change', selectedOption)
            .selectAll('option')
            //              .on('change', selectedOption)
            .append("option")
            .data(available_genres)
            .enter()
            .append('option')
            .attr('value', function (d, i) {
                return i
            })
            .text(function (d) {
                return d
            });

        $(document).ready(function() {
            $('#genresList').select2();

            $('#genresList').on('select2:select', function (e) {
                var data = e.params.data;
                console.log(data);
                console.log("Current Selection:");
                console.log($('#genresList').select2('data'));
            });
        });

//        d3.select('body')
//            .select('#fuzzSearch')
//            //            .select("#fuzzName")
//            .on('change', selectedOption);


//        $('#fuzzOptionsList').fuzzyDropdown({
//            mainContainer: '#fuzzSearch',
//            arrowUpClass: 'fuzzArrowUp',
//            selectedClass: 'selected',
//            enableBrowserDefaultScroll: true
//        });


        drawPlot(dataset);

        d3.select("#map-container")
            .datum(data)
            .call(leafletMap);


        playButton
            .on("click", function () {
                var button = d3.select(this);
                if (button.text() == "Pause") {
                    moving = false;
                    clearInterval(timer);
                    // timer = 0;
                    button.text("Play");
                } else {
                    moving = true;
                    timer = setInterval(step, 100);
                    button.text("Pause");
                }
                console.log("Slider moving: " + moving);
            })
    });

    function buildMap(obj) {
        let map = new Map();
        Object.keys(obj).forEach(key => {
            map.set(parseInt(key), obj[key]);
        });
        return map;
    }

    function prepare(d) {
        d.id = parseInt(d.id);
        d.date = parseDate(d.date);
        d.value = parseInt(d.value);
        d.x = parseFloat(d.x);
        d.y = parseFloat(d.y);
        d.genre_code = JSON.parse(d.genre_code);
        d.genre = [];
        for (i = 0; i < d.genre_code.length; i++) {
            d.genre.push(code2genre[d.genre_code[i]]);
        }
        return d;
    }

    function step() {
        update(x.invert(currentValue));
        currentValue = currentValue + (targetValue / 151);
        if (currentValue > targetValue) {
            moving = false;
            currentValue = 0;
            clearInterval(timer);
            // timer = 0;
            playButton.text("Play");
            console.log("Slider moving: " + moving);
        }
    }

    var myMap = leafletMap();
    //        .x(function(d) { return formatDate.parse(d.date); })
    //        .y(function(d) { return +d.price; });

    //    var formatDate = d3.time.format("%b %Y");

    var count = 0

    function drawPlot(data) {
        console.log(data.length)
        console.log("draw is called!")
        var locations = plot.select("#map-container")
            .datum(data)
            .call(myMap);

//        heatmapLayer.setData(loadData(count, 300));
        heatmapLayer.setData(loadData(data));
//        count+=300;

//        console.log(locations)

//        // if filtered dataset has more circles than already existing, transition new ones in
//        locations.enter().call(leafletMap);
//            .append("circle")
//            .attr("class", "location")
//            .attr("cx", function (d) {
//                return x(d.date);
//            })
//            .attr("cy", height / 2)
//            .style("fill", function (d) {
//                return d3.hsl(d.date / 1000000000, 0.8, 0.8)
//            })
//            .style("stroke", function (d) {
//                return d3.hsl(d.date / 1000000000, 0.7, 0.7)
//            })
//            .style("opacity", 0.5)
//            .attr("r", 8)
//            .transition()
//            .duration(400)
//            .attr("r", 25)
//            .transition()
//            .attr("r", 8);

        // if filtered dataset has less circles than already existing, remove excess
//        locations.exit()
//            .remove();
    }

    function update(h) {
        console.log(h);
//        console.log(typeof h);
        console.log(d3.timeDay.offset(h, 1));
        // update position and text of label according to slider scale
        handle.attr("cx", x(h));
        label
            .attr("x", x(h))
            .text(formatDate(h));

        // filter data set and redraw plot
        var newData = dataset.filter(function (d) {
            return (d.date > h) && (d.date <= d3.timeDay.offset(h, 5));
        });
        drawPlot(newData);
//        drawPlot(dataset);
//        console.log(dataset.length)
    }

</script>
</body>